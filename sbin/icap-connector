#!/usr/bin/env python

import socket
import sys


def log(prefix, string):
	return
	sys.stderr.write('%-6s %s\n' % (prefix,string.replace('\r','\\r').replace('\n','\\n')))
	with open('/tmp/log', 'a+') as fd:
		fd.write('%-6s %s\n' % (prefix,string.replace('\r','\\r').replace('\n','\\n')))


def main (host, port):
	sock = None
	while True:
		try:
			data = ''

			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			sock.connect((host,port))

			def read (size=1,end=None,buffered=['']):
				buf_data = buffered.pop()

				if end is not None:
					if end in buf_data:
						returned,buf_data = buf_data.split(end,1)
						buffered.append(buf_data)
						return returned + end
					else:
						buf_data += sock.recv(4016)
						buffered.append(buf_data)
						return read(end=end)

				buf_size = len(buf_data)

				if size <= buf_size:
					buf_size -= size
					returned, buf_data = buf_data[:size],buf_data[size:]
					buffered.append(buf_data)
					return returned

				read_size = size - len(buf_data)
				while read_size > 0:
					extra = sock.recv(read_size)
					read_size -= len(extra)
					buf_data += extra
				buffered.append('')
				return buf_data

			def read_size ():
				total = 0
				string = ''
				while True:
					byte = read(1)
					string += byte
					# this allows '\r\n' to be zero which is wrong but simple
					if byte == '\r':
						continue
					if byte == '\n':
						return total, string
					total = total * 16
					log('TEST',byte)
					total = total + int(byte,16)

			while True:
				looping = 2
				while looping:
					line = sys.stdin.readline()
					log('STDIN',line)
					if not line.startswith('Pragma:'):
						log('SEND',line.strip()+'\r\n')
						sock.send(line.strip()+'\r\n')
					if not line.strip():
						looping -= 1

				while True:
					recv = read(end='\n')
					log('RECV',recv)
					data += recv
					if '\r\n\r\n' in data:
						break

				response,data = data.split('\r\n\r\n',1)

				sys.stdout.write(response + '\r\n\r\n')
				sys.stdout.flush()
				log('STDOUT',response + '\r\n\r\n')

				# ExaProxy always put the encapsulation last, this is not a RFC behaviour
				encapsulation = response.split('\r\n')[-1]

				# Encapsulated: req-hdr=0, null-body=135
				# Encapsulated: res-hdr=0, res-body=226
				headers = dict((k.strip(),int(v)) for k,v in (_.split('=') for _ in encapsulation.split(':')[-1].split(',')))
				# this is wrong in theory .. in practice it works

				if 'req-hdr' in headers:
					response = read(headers['null-body'])
				# chunk encoded
				elif 'res-hdr' in headers:
					response = read(headers['res-body'])

					chunk_size = -1
					while True:
						chunk_size, chunk_data = read_size()
						response += chunk_data
						chunk = read(chunk_size)
						response += chunk
						if chunk_size == 0:
							break
						eol = read(2)
						response += eol
				else:
					log('FATAL', 'unknown encapsulation [%s]' % encapsulation)

				sys.stdout.write(response)
				sys.stdout.flush()
				log('STDOUT',response)

		except KeyboardInterrupt:
			sys.exit(0)

		except (IOError, socket.error):
			if sock:
				try:
					sock.close()
				except Exception:
					pass
				finally:
					sock = None

		except Exception, e:
			sock.close()
			sys.stderr.write('exaproxy surfprotect connector failed\n')
			sys.stderr.write(str(e))
			sys.exit(1)


if __name__ == '__main__':
	main(
		sys.argv[1],
		1344 if len(sys.argv) < 3 else int(sys.argv[2])
	)
